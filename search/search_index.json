{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the typing-exe documentation! A table of contents will be placed here.","title":"Home"},{"location":"assert/","text":"Add simple boolean checks on your parameters or return-values. Usage from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b Description As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, foo in the example above, is decorated with @execute_annotations). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function (foo in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Assert"},{"location":"assert/#usage","text":"from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b","title":"Usage"},{"location":"assert/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, foo in the example above, is decorated with @execute_annotations). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function (foo in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Description"},{"location":"cleanup_annotations/","text":"","title":"cleanup_annotations"},{"location":"early_return/","text":"","title":"EarlyReturn"},{"location":"execute_annotations/","text":"","title":"execute_annotations"},{"location":"modify/","text":"Modify your parameters before or your return values after execution of your function-body. Usage from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b < 10_000 else r/100]: return a - b The example is completely meaningless and only serves to demonstrate the how-to, not the why, of using Modify . Description As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function (foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas.","title":"Modify"},{"location":"modify/#usage","text":"from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b < 10_000 else r/100]: return a - b The example is completely meaningless and only serves to demonstrate the how-to, not the why, of using Modify .","title":"Usage"},{"location":"modify/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function (foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas.","title":"Description"},{"location":"parameter_data/","text":"","title":"ParameterData"},{"location":"quickstart/","text":"Quickstart","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"sequence/","text":"","title":"Sequence"}]}