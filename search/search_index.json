{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Executable typehints for Python: make assertions about and/or modify parameters & return values. Example from typing_exe.annotations import Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Modify[lambda a: float(a)], b: Assert[float, lambda b: b != 0] ) -> float: return a / b What's going on here? From the bottom to the top: The function divide divides two numbers Its parameters have executable annotations: a is annotated by Modify . This means that when divide is called, before the function-body is executed, a is cast to float b is annotated by Assert . This means that when divide is called, before the function-body is executed, a check runs and raises a ValueError if b is zero @execute_annotations enables the execution of these decorators. Without it, the annotations are in the way. @cleanup_annotations removes the Modify and Assert from the function's annotations so that divide can for used by other tools like strongtyping . But why? Few things are more useful in programming than the ability to constrain a program's possible behaviors and communicate those constraints clearly in code. Statically typed languages do this with types, scope modifiers, and lifetime modifiers, among others ( int , static , private , const , etc.). These are static constraints in that they are evaluated statically, before runtime. Oftentimes, a program also has dynamic constraints, evaluated during runtime\u2014assertions, for example. A function dealing with division, for example, has to deal with the special case of division by zero. Replacing parameter-checks in the function-body with enforceable typehints in the function-signature might have the following advantages: Make code more readable by having constraints in a predefined place Encourage programmers to think about these constraints while writing the functions\u2014a type of test-driven development directly at the function (seeing parts of the \"tests\" in the function-signature might assist readability of code, as well) Make code easier to write by providing important information about APIs in a glancable way This would of course require editor-support, which I do not provide Make it possible to include information on dynamic constraints in automatically generated documentation","title":"Home"},{"location":"#example","text":"from typing_exe.annotations import Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Modify[lambda a: float(a)], b: Assert[float, lambda b: b != 0] ) -> float: return a / b What's going on here? From the bottom to the top: The function divide divides two numbers Its parameters have executable annotations: a is annotated by Modify . This means that when divide is called, before the function-body is executed, a is cast to float b is annotated by Assert . This means that when divide is called, before the function-body is executed, a check runs and raises a ValueError if b is zero @execute_annotations enables the execution of these decorators. Without it, the annotations are in the way. @cleanup_annotations removes the Modify and Assert from the function's annotations so that divide can for used by other tools like strongtyping .","title":"Example"},{"location":"#but-why","text":"Few things are more useful in programming than the ability to constrain a program's possible behaviors and communicate those constraints clearly in code. Statically typed languages do this with types, scope modifiers, and lifetime modifiers, among others ( int , static , private , const , etc.). These are static constraints in that they are evaluated statically, before runtime. Oftentimes, a program also has dynamic constraints, evaluated during runtime\u2014assertions, for example. A function dealing with division, for example, has to deal with the special case of division by zero. Replacing parameter-checks in the function-body with enforceable typehints in the function-signature might have the following advantages: Make code more readable by having constraints in a predefined place Encourage programmers to think about these constraints while writing the functions\u2014a type of test-driven development directly at the function (seeing parts of the \"tests\" in the function-signature might assist readability of code, as well) Make code easier to write by providing important information about APIs in a glancable way This would of course require editor-support, which I do not provide Make it possible to include information on dynamic constraints in automatically generated documentation","title":"But why?"},{"location":"assert/","text":"Assert Add simple boolean checks on your parameters or return-values. Simple example Below is the simple example of a constrained division-function. The example from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b Explanation What happens when divide is called? The first Assert is checked. If a is smaller than 0, a ValueError is raised The second Assert is checked. If b is equal to 0, a ValueError is raised The function-body is executed and the result of a / b calculated Its result is checked for plausibility by the third Assert The result is returned Description As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Assert # 1. typehint and assertions Assert[<typehint>, <assertion1>, <assertion2>, ...] # 2. only assertions Assert[<assertion1>, <assertion2>, ...] The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, divide in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function ( divide in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Assert"},{"location":"assert/#assert","text":"Add simple boolean checks on your parameters or return-values.","title":"Assert"},{"location":"assert/#simple-example","text":"Below is the simple example of a constrained division-function.","title":"Simple example"},{"location":"assert/#the-example","text":"from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b","title":"The example"},{"location":"assert/#explanation","text":"What happens when divide is called? The first Assert is checked. If a is smaller than 0, a ValueError is raised The second Assert is checked. If b is equal to 0, a ValueError is raised The function-body is executed and the result of a / b calculated Its result is checked for plausibility by the third Assert The result is returned","title":"Explanation"},{"location":"assert/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Assert # 1. typehint and assertions Assert[<typehint>, <assertion1>, <assertion2>, ...] # 2. only assertions Assert[<assertion1>, <assertion2>, ...] The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, divide in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function ( divide in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Description"},{"location":"cleanup_annotations/","text":"","title":"cleanup_annotations"},{"location":"early_return/","text":"EarlyReturn Communicate to Modify and Sequence to stop function-execution and return the value given to EarlyReturn . Does not work for Assert . Example The example from some_package import load_fct, save_fct from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def load_img(a: str): filename = a.split(\".\")[:-1] fileformat = a.split(\".\")[-1] if fileformat == \"pdf\": # a was already sharpened and was saved as a pdf-file # -> sharpen_img should simply return the loaded data pdf = load_fct(a) return EarlyReturn(pdf) # Load the image and give it and the filename to sharpen_img image = load_fct(a, fileformat=fileformat) return filename, image @execute_annotations def sharpen_img(a: Modify[str, load_img]): filename, image = *a # Sharpen the image here image = ... # Save the result save_fct(filename + \".pdf\", image) # Return sharpened image return image Explanation The function sharpen_img is used to load an image from a file given by name. It loads the image in load_img \u2014executed in Modify \u2014sharpens it, saves it as a PDF-file, and then returns the sharpened image. If the file given to it is already in PDF-format, that means that it has already been sharpened and so load_img loads it and returns an EarlyReturn of the loaded, sharpened image. The function-body of sharpen_img will not be executed; instead, the sharpened image will be returned immediately. EarlyReturn returns The value that should be returned early","title":"EarlyReturn"},{"location":"early_return/#earlyreturn","text":"Communicate to Modify and Sequence to stop function-execution and return the value given to EarlyReturn . Does not work for Assert .","title":"EarlyReturn"},{"location":"early_return/#example","text":"","title":"Example"},{"location":"early_return/#the-example","text":"from some_package import load_fct, save_fct from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def load_img(a: str): filename = a.split(\".\")[:-1] fileformat = a.split(\".\")[-1] if fileformat == \"pdf\": # a was already sharpened and was saved as a pdf-file # -> sharpen_img should simply return the loaded data pdf = load_fct(a) return EarlyReturn(pdf) # Load the image and give it and the filename to sharpen_img image = load_fct(a, fileformat=fileformat) return filename, image @execute_annotations def sharpen_img(a: Modify[str, load_img]): filename, image = *a # Sharpen the image here image = ... # Save the result save_fct(filename + \".pdf\", image) # Return sharpened image return image","title":"The example"},{"location":"early_return/#explanation","text":"The function sharpen_img is used to load an image from a file given by name. It loads the image in load_img \u2014executed in Modify \u2014sharpens it, saves it as a PDF-file, and then returns the sharpened image. If the file given to it is already in PDF-format, that means that it has already been sharpened and so load_img loads it and returns an EarlyReturn of the loaded, sharpened image. The function-body of sharpen_img will not be executed; instead, the sharpened image will be returned immediately.","title":"Explanation"},{"location":"early_return/#earlyreturn_1","text":"returns The value that should be returned early","title":"EarlyReturn"},{"location":"execute_annotations/","text":"","title":"execute_annotations"},{"location":"modify/","text":"Modify Modify your parameters before or your return values after execution of your function-body. Simple example Below is a quick example meant to show the How (though maybe not the Why) of using Modify . The example from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b > 10_000 else r * 100]: return a - b Explanation What happens when this function is called? For example, consider calling foo(2.0, -1.0) . Before the function body is called, a and b are modified a is given the value 31 according to the equation in its Modify -annotation b is given the value 1.0 The function body is executed The return-value is modified. Since a + b < 10_000 is True , the actual return value of foo(2.0, -1.0) is 30 * 100 == 3_000 The modifications are only executed if @execute_annotations is present. Due to the presence of @cleanup_annotations , foo.__annotations__ will be {'b': <class 'int'>} , disregarding the executable annotations. Description As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Modify # 1. typehint and modifications Modify[<typehint>, <modification1>, <modification2>, ...] # 2. only modifications Modify[<modification1>, <modification2>, ...] The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function ( foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas. Larger example import PIL import torch import torchvision as tv from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations train_mean = [0.59685254, 0.59685254, 0.59685254] train_std = [0.16043035, 0.16043035, 0.16043035] transform_to_tensor = tv.transforms.Compose([ tv.transforms.ToPILImage(), tv.transforms.ToTensor() ]) normalize = tv.transforms.Normalize(mean=train_mean, std=train_std) transform_flip = tv.transforms.Compose([ tv.transforms.RandomHorizontalFlip(), tv.transforms.RandomVerticalFlip() ]) transform_colors = tv.transforms.Compose([ tv.transforms.RandomInvert(), tv.transforms.RandomEqualize() ]) # Model1 and Model2 are both used with the same DataLoader the returns PIL.Images class Model1(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize]): ... class Model2(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize, transform_flip]): ... # Model3 and Model4 use a DataLoader that already returns torch.tensors class Model3(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize]): ... class Model4(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize, transform_colors, transform_flip]): ...","title":"Modify"},{"location":"modify/#modify","text":"Modify your parameters before or your return values after execution of your function-body.","title":"Modify"},{"location":"modify/#simple-example","text":"Below is a quick example meant to show the How (though maybe not the Why) of using Modify .","title":"Simple example"},{"location":"modify/#the-example","text":"from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b > 10_000 else r * 100]: return a - b","title":"The example"},{"location":"modify/#explanation","text":"What happens when this function is called? For example, consider calling foo(2.0, -1.0) . Before the function body is called, a and b are modified a is given the value 31 according to the equation in its Modify -annotation b is given the value 1.0 The function body is executed The return-value is modified. Since a + b < 10_000 is True , the actual return value of foo(2.0, -1.0) is 30 * 100 == 3_000 The modifications are only executed if @execute_annotations is present. Due to the presence of @cleanup_annotations , foo.__annotations__ will be {'b': <class 'int'>} , disregarding the executable annotations.","title":"Explanation"},{"location":"modify/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Modify # 1. typehint and modifications Modify[<typehint>, <modification1>, <modification2>, ...] # 2. only modifications Modify[<modification1>, <modification2>, ...] The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function ( foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas.","title":"Description"},{"location":"modify/#larger-example","text":"import PIL import torch import torchvision as tv from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations train_mean = [0.59685254, 0.59685254, 0.59685254] train_std = [0.16043035, 0.16043035, 0.16043035] transform_to_tensor = tv.transforms.Compose([ tv.transforms.ToPILImage(), tv.transforms.ToTensor() ]) normalize = tv.transforms.Normalize(mean=train_mean, std=train_std) transform_flip = tv.transforms.Compose([ tv.transforms.RandomHorizontalFlip(), tv.transforms.RandomVerticalFlip() ]) transform_colors = tv.transforms.Compose([ tv.transforms.RandomInvert(), tv.transforms.RandomEqualize() ]) # Model1 and Model2 are both used with the same DataLoader the returns PIL.Images class Model1(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize]): ... class Model2(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize, transform_flip]): ... # Model3 and Model4 use a DataLoader that already returns torch.tensors class Model3(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize]): ... class Model4(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize, transform_colors, transform_flip]): ...","title":"Larger example"},{"location":"parameter_data/","text":"ParameterData A dataclass that holds information about a function that is annotated by @execute_annotations . It is recommended that users don't use this class directly. However, a short description of its members is provided below anyways. ParameterData function_signature: inspect.Signature The signature of the function arg_annotations: dict A dictionary in the form {parameter-index: annotation} . Only includes annotations from the typing-exe -package argname_from_index: dict A dictionary in the form {parameter-index: parameter-name} index_from_argname: dict A dictinary in the form {parameter-name: parameter-index} kwarg_annotations: dict A dictionary in the form {parameter-name: annotation} . Only includes annotations from the typing-exe -package defaultdata: dict A dictionary in the form {parameter-name: {\"index\": parameter-index, \"value\": parameter-value}}","title":"ParameterData"},{"location":"parameter_data/#parameterdata","text":"A dataclass that holds information about a function that is annotated by @execute_annotations . It is recommended that users don't use this class directly. However, a short description of its members is provided below anyways.","title":"ParameterData"},{"location":"parameter_data/#parameterdata_1","text":"function_signature: inspect.Signature The signature of the function arg_annotations: dict A dictionary in the form {parameter-index: annotation} . Only includes annotations from the typing-exe -package argname_from_index: dict A dictionary in the form {parameter-index: parameter-name} index_from_argname: dict A dictinary in the form {parameter-name: parameter-index} kwarg_annotations: dict A dictionary in the form {parameter-name: annotation} . Only includes annotations from the typing-exe -package defaultdata: dict A dictionary in the form {parameter-name: {\"index\": parameter-index, \"value\": parameter-value}}","title":"ParameterData"},{"location":"quickstart/","text":"Quickstart","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"sequence/","text":"Sequence String together Assert and Modify annotations. Basic example The example from typing_exe.annotations import Sequence, Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Sequence[ int, Assert[lambda a: type(a) is int, lambda a: a != 0], Modify[lambda a: abs(a)], Assert[lambda a: a > 5] ] ): ... Explanation When foo gets executed, the following will happen: The first Assert will check a 's type, then check that it is not zero The Modify will then return the absolute value of a The second Assert will check that a is now greater than five The function-body will be executed Description The first entry to the Sequence.__getitem__ -method can either be a typehint or an Assert or Modify . All other entries have to be either an Assert or a Modify . Here are some legal calls to Sequence : from typing_exe.annotations import Sequence, Assert, Modify Sequence[int, Assert[...], Modify[...]] Sequence[Assert[...], Modify[...]] Sequence[Modify[...], Modify[...], Modify[...]] Sequence[str, Modify[...]] Sequence[Assert[...]] # not very useful","title":"Sequence"},{"location":"sequence/#sequence","text":"String together Assert and Modify annotations.","title":"Sequence"},{"location":"sequence/#basic-example","text":"","title":"Basic example"},{"location":"sequence/#the-example","text":"from typing_exe.annotations import Sequence, Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Sequence[ int, Assert[lambda a: type(a) is int, lambda a: a != 0], Modify[lambda a: abs(a)], Assert[lambda a: a > 5] ] ): ...","title":"The example"},{"location":"sequence/#explanation","text":"When foo gets executed, the following will happen: The first Assert will check a 's type, then check that it is not zero The Modify will then return the absolute value of a The second Assert will check that a is now greater than five The function-body will be executed","title":"Explanation"},{"location":"sequence/#description","text":"The first entry to the Sequence.__getitem__ -method can either be a typehint or an Assert or Modify . All other entries have to be either an Assert or a Modify . Here are some legal calls to Sequence : from typing_exe.annotations import Sequence, Assert, Modify Sequence[int, Assert[...], Modify[...]] Sequence[Assert[...], Modify[...]] Sequence[Modify[...], Modify[...], Modify[...]] Sequence[str, Modify[...]] Sequence[Assert[...]] # not very useful","title":"Description"}]}