{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"typing-exe Executable typehints for Python: make assertions about and/or modify parameters & return values. GitHub page: snimu/typing-exe Example from typing_exe.annotations import Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Modify[lambda a: float(a)], b: Assert[float, lambda b: b != 0] ) -> float: return a / b What's going on here? From the bottom to the top: The function divide divides two numbers Its parameters have executable annotations: a is annotated by Modify . This means that when divide is called, before the function-body is executed, a is cast to float b is annotated by Assert . This means that when divide is called, before the function-body is executed, a check runs and raises a ValueError if b is zero @execute_annotations enables the execution of these decorators. Without it, the annotations are in the way. @cleanup_annotations removes the Modify and Assert from the function's annotations so that divide can for used by other tools like strongtyping . But why? Few things are more useful in programming than the ability to constrain a program's possible behaviors and communicate those constraints clearly in code. Statically typed languages do this with types, scope modifiers, and lifetime modifiers, among others ( int , static , private , const , etc.). These are static constraints in that they are evaluated statically, before runtime. Oftentimes, a program also has dynamic constraints, evaluated during runtime\u2014assertions, for example. A function dealing with division, for example, has to deal with the special case of division by zero. Replacing parameter-checks in the function-body with enforceable typehints in the function-signature might have the following advantages: Make code more readable by having constraints in a predefined place Encourage programmers to think about these constraints while writing the functions\u2014a type of test-driven development directly at the function (seeing parts of the \"tests\" in the function-signature might assist readability of code, as well) Make code easier to write by providing important information about APIs in a glancable way This would of course require editor-support, which I do not provide Make it possible to include information on dynamic constraints in automatically generated documentation","title":"Home"},{"location":"#typing-exe","text":"Executable typehints for Python: make assertions about and/or modify parameters & return values. GitHub page: snimu/typing-exe","title":"typing-exe"},{"location":"#example","text":"from typing_exe.annotations import Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Modify[lambda a: float(a)], b: Assert[float, lambda b: b != 0] ) -> float: return a / b What's going on here? From the bottom to the top: The function divide divides two numbers Its parameters have executable annotations: a is annotated by Modify . This means that when divide is called, before the function-body is executed, a is cast to float b is annotated by Assert . This means that when divide is called, before the function-body is executed, a check runs and raises a ValueError if b is zero @execute_annotations enables the execution of these decorators. Without it, the annotations are in the way. @cleanup_annotations removes the Modify and Assert from the function's annotations so that divide can for used by other tools like strongtyping .","title":"Example"},{"location":"#but-why","text":"Few things are more useful in programming than the ability to constrain a program's possible behaviors and communicate those constraints clearly in code. Statically typed languages do this with types, scope modifiers, and lifetime modifiers, among others ( int , static , private , const , etc.). These are static constraints in that they are evaluated statically, before runtime. Oftentimes, a program also has dynamic constraints, evaluated during runtime\u2014assertions, for example. A function dealing with division, for example, has to deal with the special case of division by zero. Replacing parameter-checks in the function-body with enforceable typehints in the function-signature might have the following advantages: Make code more readable by having constraints in a predefined place Encourage programmers to think about these constraints while writing the functions\u2014a type of test-driven development directly at the function (seeing parts of the \"tests\" in the function-signature might assist readability of code, as well) Make code easier to write by providing important information about APIs in a glancable way This would of course require editor-support, which I do not provide Make it possible to include information on dynamic constraints in automatically generated documentation","title":"But why?"},{"location":"assert/","text":"Assert Add simple boolean checks on your parameters or return-values. Simple example Below is the simple example of a constrained division-function. The example from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b Explanation What happens when divide is called? The first Assert is checked. If a is smaller than 0, a ValueError is raised The second Assert is checked. If b is equal to 0, a ValueError is raised The function-body is executed and the result of a / b calculated Its result is checked for plausibility by the third Assert The result is returned Description As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Assert # 1. typehint and assertions Assert[<typehint>, <assertion1>, <assertion2>, ...] # 2. only assertions Assert[<assertion1>, <assertion2>, ...] The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, divide in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function ( divide in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Assert"},{"location":"assert/#assert","text":"Add simple boolean checks on your parameters or return-values.","title":"Assert"},{"location":"assert/#simple-example","text":"Below is the simple example of a constrained division-function.","title":"Simple example"},{"location":"assert/#the-example","text":"from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def divide( a: Assert[lambda a: a >= 0], b: Assert[float, lambda b: b != 0] ) -> Assert[lambda r, a, b: r < a if b > 1 else r >= a]: return a / b","title":"The example"},{"location":"assert/#explanation","text":"What happens when divide is called? The first Assert is checked. If a is smaller than 0, a ValueError is raised The second Assert is checked. If b is equal to 0, a ValueError is raised The function-body is executed and the result of a / b calculated Its result is checked for plausibility by the third Assert The result is returned","title":"Explanation"},{"location":"assert/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or an assertion. All other entries are assertions (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Assert # 1. typehint and assertions Assert[<typehint>, <assertion1>, <assertion2>, ...] # 2. only assertions Assert[<assertion1>, <assertion2>, ...] The typehint will be ignored by Assert. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The assertions are not in the form of assert -statements but in the form of functions that take the parameter and return a boolean value. If that boolean value is False , a ValueError will be raised (this only works if your function, divide in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your assertion-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the assertion-function (the lambda in the return-annotation in the example) and the annotated function ( divide in the example above). The name of the parameter itself in the assertion-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this assertion-function. For example, the following works: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda whatever, a: whatever > a]): ... But this doesn't: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, whatever: b > whatever]): ... Good form would be the following: from typing_exe.annotations import Assert def foo(a, b: Assert[lambda b, a: b > a]): ... Of course, the assertion-functions don't have to be lambdas.","title":"Description"},{"location":"cleanup_annotations/","text":"cleanup_annotations Remove annotations from the typing-exe package to leave your function with clean __annotations__ . Example from typing_exe.annotations import Assert, Modify, Sequence from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: int, b, c: Assert[lambda c: c > 5], d: Modify[int, lambda d: d / 2] ) -> Sequence[ str, Assert[lambda r: len(r) < 20], Modify[lambda r: r if r.endswith(\".pdf\") else r + \".pdf\"] ]: ... # foo.__annotations__: {'a': <class 'int'>, 'd': <class 'int'>, 'return': <class 'str'>} Explanation Without @cleanup_annotations , foo.__annotations__ from the example above would be very complex and\u2014importantly\u2014unusable for other packages such as strongtyping . With it, they are {'a': <class 'int'>, 'd': <class 'int'>, 'return': <class 'str'>} . @execute_annotations does not automatically do this so that users can, if they want to, not use @cleanup_annotations and work with the annotations that include Assert , Modify , and Sequence . Caveat @cleanup_annotations does not go into your annotations recursively. If you have one of the annotations from typing-exe inside of a regular typehint\u2014for example, Union[int, Assert[...]] \u2014then it will not be removed. In other words, only use Assert , Modify , and Sequence directly, not inside other annotations.","title":"cleanup_annotations"},{"location":"cleanup_annotations/#cleanup_annotations","text":"Remove annotations from the typing-exe package to leave your function with clean __annotations__ .","title":"cleanup_annotations"},{"location":"cleanup_annotations/#example","text":"from typing_exe.annotations import Assert, Modify, Sequence from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: int, b, c: Assert[lambda c: c > 5], d: Modify[int, lambda d: d / 2] ) -> Sequence[ str, Assert[lambda r: len(r) < 20], Modify[lambda r: r if r.endswith(\".pdf\") else r + \".pdf\"] ]: ... # foo.__annotations__: {'a': <class 'int'>, 'd': <class 'int'>, 'return': <class 'str'>}","title":"Example"},{"location":"cleanup_annotations/#explanation","text":"Without @cleanup_annotations , foo.__annotations__ from the example above would be very complex and\u2014importantly\u2014unusable for other packages such as strongtyping . With it, they are {'a': <class 'int'>, 'd': <class 'int'>, 'return': <class 'str'>} . @execute_annotations does not automatically do this so that users can, if they want to, not use @cleanup_annotations and work with the annotations that include Assert , Modify , and Sequence .","title":"Explanation"},{"location":"cleanup_annotations/#caveat","text":"@cleanup_annotations does not go into your annotations recursively. If you have one of the annotations from typing-exe inside of a regular typehint\u2014for example, Union[int, Assert[...]] \u2014then it will not be removed. In other words, only use Assert , Modify , and Sequence directly, not inside other annotations.","title":"Caveat"},{"location":"early_return/","text":"EarlyReturn Communicate to Modify and Sequence to stop function-execution and return the value given to EarlyReturn . Does not work for Assert . Example The example from some_package import load_fct, save_fct from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def load_img(a: str): filename = a.split(\".\")[:-1] fileformat = a.split(\".\")[-1] if fileformat == \"pdf\": # a was already sharpened and was saved as a pdf-file # -> sharpen_img should simply return the loaded data pdf = load_fct(a) return EarlyReturn(pdf) # Load the image and give it and the filename to sharpen_img image = load_fct(a, fileformat=fileformat) return filename, image @execute_annotations def sharpen_img(a: Modify[str, load_img]): filename, image = *a # Sharpen the image here image = ... # Save the result save_fct(filename + \".pdf\", image) # Return sharpened image return image Explanation The function sharpen_img is used to load an image from a file given by name. It loads the image in load_img \u2014executed in Modify \u2014sharpens it, saves it as a PDF-file, and then returns the sharpened image. If the file given to it is already in PDF-format, that means that it has already been sharpened and so load_img loads it and returns an EarlyReturn of the loaded, sharpened image. The function-body of sharpen_img will not be executed; instead, the sharpened image will be returned immediately. EarlyReturn for default parameters EarlyReturn can even be used as a default value! This way, if a parameter to a function is unfilled, a default can be returned immediately. from typing import Union from typing_exe.early_return import EarlyReturn from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Union[str, EarlyReturn] = EarlyReturn(\"well that was quick\")): ... If you are using type-checkers, EarlyReturn of course has to be allowed as a type to the parameter, as seen in the example above. EarlyReturn returns The value that should be returned early","title":"EarlyReturn"},{"location":"early_return/#earlyreturn","text":"Communicate to Modify and Sequence to stop function-execution and return the value given to EarlyReturn . Does not work for Assert .","title":"EarlyReturn"},{"location":"early_return/#example","text":"","title":"Example"},{"location":"early_return/#the-example","text":"from some_package import load_fct, save_fct from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def load_img(a: str): filename = a.split(\".\")[:-1] fileformat = a.split(\".\")[-1] if fileformat == \"pdf\": # a was already sharpened and was saved as a pdf-file # -> sharpen_img should simply return the loaded data pdf = load_fct(a) return EarlyReturn(pdf) # Load the image and give it and the filename to sharpen_img image = load_fct(a, fileformat=fileformat) return filename, image @execute_annotations def sharpen_img(a: Modify[str, load_img]): filename, image = *a # Sharpen the image here image = ... # Save the result save_fct(filename + \".pdf\", image) # Return sharpened image return image","title":"The example"},{"location":"early_return/#explanation","text":"The function sharpen_img is used to load an image from a file given by name. It loads the image in load_img \u2014executed in Modify \u2014sharpens it, saves it as a PDF-file, and then returns the sharpened image. If the file given to it is already in PDF-format, that means that it has already been sharpened and so load_img loads it and returns an EarlyReturn of the loaded, sharpened image. The function-body of sharpen_img will not be executed; instead, the sharpened image will be returned immediately.","title":"Explanation"},{"location":"early_return/#earlyreturn-for-default-parameters","text":"EarlyReturn can even be used as a default value! This way, if a parameter to a function is unfilled, a default can be returned immediately. from typing import Union from typing_exe.early_return import EarlyReturn from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Union[str, EarlyReturn] = EarlyReturn(\"well that was quick\")): ... If you are using type-checkers, EarlyReturn of course has to be allowed as a type to the parameter, as seen in the example above.","title":"EarlyReturn for default parameters"},{"location":"early_return/#earlyreturn_1","text":"returns The value that should be returned early","title":"EarlyReturn"},{"location":"execute_annotations/","text":"execute_annotations All callables annotated by @execute_annotations will execute all correctly placed Assert -, Modify -, and Sequence -annotations in the callable's signature when called. Without this decorator, annotations from the typing-exe -package are dead code. For usage-details, see the Assert -, Modify -, and Sequence -pages, or Quickstart .","title":"execute_annotations"},{"location":"execute_annotations/#execute_annotations","text":"All callables annotated by @execute_annotations will execute all correctly placed Assert -, Modify -, and Sequence -annotations in the callable's signature when called. Without this decorator, annotations from the typing-exe -package are dead code. For usage-details, see the Assert -, Modify -, and Sequence -pages, or Quickstart .","title":"execute_annotations"},{"location":"modify/","text":"Modify Modify your parameters before or your return values after execution of your function-body. Simple example Below is a quick example meant to show the How (though maybe not the Why) of using Modify . The example from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b > 10_000 else r * 100]: return a - b Explanation What happens when this function is called? For example, consider calling foo(2.0, -1.0) . Before the function body is called, a and b are modified a is given the value 31 according to the equation in its Modify -annotation b is given the value 1.0 The function body is executed The return-value is modified. Since a + b < 10_000 is True , the actual return value of foo(2.0, -1.0) is 30 * 100 == 3_000 The modifications are only executed if @execute_annotations is present. Due to the presence of @cleanup_annotations , foo.__annotations__ will be {'b': <class 'int'>} , disregarding the executable annotations. Description As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Modify # 1. typehint and modifications Modify[<typehint>, <modification1>, <modification2>, ...] # 2. only modifications Modify[<modification1>, <modification2>, ...] The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function ( foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas. Larger example import PIL import torch import torchvision as tv from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations train_mean = [0.59685254, 0.59685254, 0.59685254] train_std = [0.16043035, 0.16043035, 0.16043035] transform_to_tensor = tv.transforms.Compose([ tv.transforms.ToPILImage(), tv.transforms.ToTensor() ]) normalize = tv.transforms.Normalize(mean=train_mean, std=train_std) transform_flip = tv.transforms.Compose([ tv.transforms.RandomHorizontalFlip(), tv.transforms.RandomVerticalFlip() ]) transform_colors = tv.transforms.Compose([ tv.transforms.RandomInvert(), tv.transforms.RandomEqualize() ]) # Model1 and Model2 are both used with the same DataLoader the returns PIL.Images class Model1(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize]): ... class Model2(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize, transform_flip]): ... # Model3 and Model4 use a DataLoader that already returns torch.tensors class Model3(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize]): ... class Model4(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize, transform_colors, transform_flip]): ...","title":"Modify"},{"location":"modify/#modify","text":"Modify your parameters before or your return values after execution of your function-body.","title":"Modify"},{"location":"modify/#simple-example","text":"Below is a quick example meant to show the How (though maybe not the Why) of using Modify .","title":"Simple example"},{"location":"modify/#the-example","text":"from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Modify[lambda a: 3 + 2*a + 4*a**2 + a**3], b: Modify[float, lambda b: abs(b)] ) -> Modify[lambda r, a, b: r if a + b > 10_000 else r * 100]: return a - b","title":"The example"},{"location":"modify/#explanation","text":"What happens when this function is called? For example, consider calling foo(2.0, -1.0) . Before the function body is called, a and b are modified a is given the value 31 according to the equation in its Modify -annotation b is given the value 1.0 The function body is executed The return-value is modified. Since a + b < 10_000 is True , the actual return value of foo(2.0, -1.0) is 30 * 100 == 3_000 The modifications are only executed if @execute_annotations is present. Due to the presence of @cleanup_annotations , foo.__annotations__ will be {'b': <class 'int'>} , disregarding the executable annotations.","title":"Explanation"},{"location":"modify/#description","text":"As the two typehints in the example above show, the first entry can either be a typehint, or a modification. All other entries are modifications (an arbitrary number of them). The acceptable forms are: from typing_exe.annotations import Modify # 1. typehint and modifications Modify[<typehint>, <modification1>, <modification2>, ...] # 2. only modifications Modify[<modification1>, <modification2>, ...] The typehint will be ignored by Modify. Its purpose is twofold: Firstly, it helps readability. Secondly, when @execute_annotations is paired with @cleanup_annotations , only that typehint will be left in the function's annotations, so that the function can be used properly by other packages such as strongtyping . The modifications are functions that take the parameter, modify it, and then return it (this only works if your function, foo in the example above, is decorated with @execute_annotations ). It is also possible to make comparisons with other parameters by simply giving your modification-function more than one parameter, where the first parameter is assumed to be the one that is annotated, while the others are the other parameters. It is important that those parameters are called the same in both the modification-function (the lambda in the return-annotation in the example) and the annotated function ( foo in the example above). The name of the parameter itself in the modification-function is irrelevant but should, for readability, usually be the same as the parameter that is annotated by this modification-function. For example, the following works: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda whatever, a: whatever + a]): ... But this doesn't: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, whatever: b + whatever]): ... Good form would be the following: from typing_exe.annotations import Modify def foo(a, b: Modify[lambda b, a: b + a]): ... Of course, the modification-functions don't have to be lambdas.","title":"Description"},{"location":"modify/#larger-example","text":"import PIL import torch import torchvision as tv from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations train_mean = [0.59685254, 0.59685254, 0.59685254] train_std = [0.16043035, 0.16043035, 0.16043035] transform_to_tensor = tv.transforms.Compose([ tv.transforms.ToPILImage(), tv.transforms.ToTensor() ]) normalize = tv.transforms.Normalize(mean=train_mean, std=train_std) transform_flip = tv.transforms.Compose([ tv.transforms.RandomHorizontalFlip(), tv.transforms.RandomVerticalFlip() ]) transform_colors = tv.transforms.Compose([ tv.transforms.RandomInvert(), tv.transforms.RandomEqualize() ]) # Model1 and Model2 are both used with the same DataLoader the returns PIL.Images class Model1(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize]): ... class Model2(torch.nn.Module): @execute_annotations def forward(self, x: Modify[PIL.Image, transform_to_tensor, normalize, transform_flip]): ... # Model3 and Model4 use a DataLoader that already returns torch.tensors class Model3(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize]): ... class Model4(torch.nn.Module): @execute_annotations def forward(self, x: Modify[torch.tensor, normalize, transform_colors, transform_flip]): ...","title":"Larger example"},{"location":"parameter_data/","text":"ParameterData A dataclass that holds information about a function that is annotated by @execute_annotations . It is recommended that users don't use this class directly. However, a short description of its members is provided below anyways. ParameterData function_signature: inspect.Signature The signature of the function arg_annotations: dict A dictionary in the form {parameter-index: annotation} . Only includes annotations from the typing-exe -package argname_from_index: dict A dictionary in the form {parameter-index: parameter-name} index_from_argname: dict A dictinary in the form {parameter-name: parameter-index} kwarg_annotations: dict A dictionary in the form {parameter-name: annotation} . Only includes annotations from the typing-exe -package defaultdata: dict A dictionary in the form {parameter-name: {\"index\": parameter-index, \"value\": parameter-value}}","title":"ParameterData"},{"location":"parameter_data/#parameterdata","text":"A dataclass that holds information about a function that is annotated by @execute_annotations . It is recommended that users don't use this class directly. However, a short description of its members is provided below anyways.","title":"ParameterData"},{"location":"parameter_data/#parameterdata_1","text":"function_signature: inspect.Signature The signature of the function arg_annotations: dict A dictionary in the form {parameter-index: annotation} . Only includes annotations from the typing-exe -package argname_from_index: dict A dictionary in the form {parameter-index: parameter-name} index_from_argname: dict A dictinary in the form {parameter-name: parameter-index} kwarg_annotations: dict A dictionary in the form {parameter-name: annotation} . Only includes annotations from the typing-exe -package defaultdata: dict A dictionary in the form {parameter-name: {\"index\": parameter-index, \"value\": parameter-value}}","title":"ParameterData"},{"location":"quickstart/","text":"Quickstart Welcome to typing-exe ! Installation pip install typing-exe GitHub page snimu/typing-exe Let's begin! Let's just show the features provided by this package, one after the other. Assert: basic First off: Assert . Don't forget @execute_annotations or the annotations won't do anything! from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Assert[lambda a: a >= 0]): ... What happens when foo is called? Before the function-body is executed, the parameter a is checked with the given function (in this case a lambda, though it can be a regular function as long as it takes the parameter and returns a bool ). If that function returns True , then the function-body is executed, if it returns False , a ValueError is raised that might look something like this: <traceback> ValueError: Assert failed! - Callable: - Name: foo - Module: __main__ Assertion: - Name: <lambda> - Module: __main__ - Parameter: - Name: a - Value: -1 Assert: multiple assertions It is easy to run an arbitrary number of assertions in succession: from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Assert[lambda a: a >= 0, lambda a: a%3 == 0]): ... The assertions will be checked one after the other. If one fails, a ValueError will be raised. Assert: between parameters It is also easy to compare one parameter to others. from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a, b: Assert[lambda b, a: b > a]): ... It is important that all names correspond to the name of the parameter they refer to. The exception is the annotated parameter, though it is bad form to give it some random name. from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations # Works, good form @execute_annotations def foo(a, b: Assert[lambda b, a: b > a]): ... # Works, bad form @execute_annotations def hoo(a, b: Assert[lambda bar, a: bar > a]): ... # Doesn't work @execute_annotations def hoo(a, b: Assert[lambda b, nope: b > nope]): ... Assert: returns Of course, all of these features are available for return values (which is the reason why the first parameter to an assertion does not have to be called the same as the parameter it annotates: it would not work for return values): from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a) -> Assert[lambda r, a: r > a]: ... This Assert will be executed after the function-body, and only then will the result be returned. cleanup_annotations These type-annotations aren't the actual types that the parameter takes; they are just a way to move constraints on a callable to a place where they are immediately visible to programmers. But what if you want to use actual typehints? Don't worry, typing-exe has you covered. from typing_exe.decorators import execute_annotations, cleanup_annotations from typing_exe.annotations import Assert @cleanup_annotations @execute_annotations def foo(a: Assert[int, lambda a: a != 0]): ... Now, the Assert will be executed, but foo.__annotations__ will be {'a': <class 'int'>} , making it useful to other packages such as strongtyping . Modify Modify works exactly as Assert does, except that the modification functions are expected to return the parameter\u2014changed however you want\u2014instead of a bool . Instead of checking the returned bool and raising a ValueError if it is False , Modify will change the actual parameter. Of course, just like with Assert , the modification-functions don't have to be lambdas, the examples below just do that for brevity. from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Modify[lambda a: a + 1]): ... Before the function-body of foo is executed, a is changed by adding 1 to it. The function-body then works with that modified a . Of course, all the features of Assert are also available for Modify . This means that multiple modifications can be done in a row in one Modify -statement, Modify works in return-annotations, other parameters can be taken into account, and @cleanup_annotations will treat Modify just like Assert . There is one additional tool that can be used with Modify , however: EarlyReturn . EarlyReturn Sometimes, when some condition is satisfied, you just want to return early without having to execute the rest of the function. typing-exe has you covered! from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def modification(a): if a == 0: return EarlyReturn(1e100) # something / 0 is very big... Having a dedicated inf would be better return 1/a @execute_annotations def foo(a: Modify[modification]): ... Now, foo(0) will immediately return 1e100 without even executing the function-body (or any of the other, later annotations). Annotations before the EarlyReturn will be executed normally. EarlyReturn: default value EarlyReturn can even be used as a default value! This way, if a parameter to a function is unfilled, a default can be returned immediately. from typing import Union from typing_exe.early_return import EarlyReturn from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Union[str, EarlyReturn] = EarlyReturn(\"well that was quick\")): ... If you are using type-checkers, EarlyReturn of course has to be allowed as a type to the parameter, as seen in the example above. Sequence: chaining Assert and Modify statements Do you want to assert something about a parameter, then modify it, then check the result of that modification, then modify again, and so on, and so on? typing-exe has you covered! from typing_exe.annotations import ( Assert, Modify, Sequence ) from typing_exe.decorators import ( execute_annotations, cleanup_annotations ) @cleanup_annotations @execute_annotations def foo( a: Sequence[ float, Assert[lambda a: a != 0], Modify[lambda a, b: b / a], Assert[lambda a: 0 < a < 10_000] ], b: float ): ...","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Welcome to typing-exe ! Installation pip install typing-exe GitHub page snimu/typing-exe","title":"Quickstart"},{"location":"quickstart/#lets-begin","text":"Let's just show the features provided by this package, one after the other.","title":"Let's begin!"},{"location":"quickstart/#assert-basic","text":"First off: Assert . Don't forget @execute_annotations or the annotations won't do anything! from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Assert[lambda a: a >= 0]): ... What happens when foo is called? Before the function-body is executed, the parameter a is checked with the given function (in this case a lambda, though it can be a regular function as long as it takes the parameter and returns a bool ). If that function returns True , then the function-body is executed, if it returns False , a ValueError is raised that might look something like this: <traceback> ValueError: Assert failed! - Callable: - Name: foo - Module: __main__ Assertion: - Name: <lambda> - Module: __main__ - Parameter: - Name: a - Value: -1","title":"Assert: basic"},{"location":"quickstart/#assert-multiple-assertions","text":"It is easy to run an arbitrary number of assertions in succession: from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Assert[lambda a: a >= 0, lambda a: a%3 == 0]): ... The assertions will be checked one after the other. If one fails, a ValueError will be raised.","title":"Assert: multiple assertions"},{"location":"quickstart/#assert-between-parameters","text":"It is also easy to compare one parameter to others. from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a, b: Assert[lambda b, a: b > a]): ... It is important that all names correspond to the name of the parameter they refer to. The exception is the annotated parameter, though it is bad form to give it some random name. from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations # Works, good form @execute_annotations def foo(a, b: Assert[lambda b, a: b > a]): ... # Works, bad form @execute_annotations def hoo(a, b: Assert[lambda bar, a: bar > a]): ... # Doesn't work @execute_annotations def hoo(a, b: Assert[lambda b, nope: b > nope]): ...","title":"Assert: between parameters"},{"location":"quickstart/#assert-returns","text":"Of course, all of these features are available for return values (which is the reason why the first parameter to an assertion does not have to be called the same as the parameter it annotates: it would not work for return values): from typing_exe.annotations import Assert from typing_exe.decorators import execute_annotations @execute_annotations def foo(a) -> Assert[lambda r, a: r > a]: ... This Assert will be executed after the function-body, and only then will the result be returned.","title":"Assert: returns"},{"location":"quickstart/#cleanup_annotations","text":"These type-annotations aren't the actual types that the parameter takes; they are just a way to move constraints on a callable to a place where they are immediately visible to programmers. But what if you want to use actual typehints? Don't worry, typing-exe has you covered. from typing_exe.decorators import execute_annotations, cleanup_annotations from typing_exe.annotations import Assert @cleanup_annotations @execute_annotations def foo(a: Assert[int, lambda a: a != 0]): ... Now, the Assert will be executed, but foo.__annotations__ will be {'a': <class 'int'>} , making it useful to other packages such as strongtyping .","title":"cleanup_annotations"},{"location":"quickstart/#modify","text":"Modify works exactly as Assert does, except that the modification functions are expected to return the parameter\u2014changed however you want\u2014instead of a bool . Instead of checking the returned bool and raising a ValueError if it is False , Modify will change the actual parameter. Of course, just like with Assert , the modification-functions don't have to be lambdas, the examples below just do that for brevity. from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Modify[lambda a: a + 1]): ... Before the function-body of foo is executed, a is changed by adding 1 to it. The function-body then works with that modified a . Of course, all the features of Assert are also available for Modify . This means that multiple modifications can be done in a row in one Modify -statement, Modify works in return-annotations, other parameters can be taken into account, and @cleanup_annotations will treat Modify just like Assert . There is one additional tool that can be used with Modify , however: EarlyReturn .","title":"Modify"},{"location":"quickstart/#earlyreturn","text":"Sometimes, when some condition is satisfied, you just want to return early without having to execute the rest of the function. typing-exe has you covered! from typing_exe.early_return import EarlyReturn from typing_exe.annotations import Modify from typing_exe.decorators import execute_annotations def modification(a): if a == 0: return EarlyReturn(1e100) # something / 0 is very big... Having a dedicated inf would be better return 1/a @execute_annotations def foo(a: Modify[modification]): ... Now, foo(0) will immediately return 1e100 without even executing the function-body (or any of the other, later annotations). Annotations before the EarlyReturn will be executed normally.","title":"EarlyReturn"},{"location":"quickstart/#earlyreturn-default-value","text":"EarlyReturn can even be used as a default value! This way, if a parameter to a function is unfilled, a default can be returned immediately. from typing import Union from typing_exe.early_return import EarlyReturn from typing_exe.decorators import execute_annotations @execute_annotations def foo(a: Union[str, EarlyReturn] = EarlyReturn(\"well that was quick\")): ... If you are using type-checkers, EarlyReturn of course has to be allowed as a type to the parameter, as seen in the example above.","title":"EarlyReturn: default value"},{"location":"quickstart/#sequence-chaining-assert-and-modify-statements","text":"Do you want to assert something about a parameter, then modify it, then check the result of that modification, then modify again, and so on, and so on? typing-exe has you covered! from typing_exe.annotations import ( Assert, Modify, Sequence ) from typing_exe.decorators import ( execute_annotations, cleanup_annotations ) @cleanup_annotations @execute_annotations def foo( a: Sequence[ float, Assert[lambda a: a != 0], Modify[lambda a, b: b / a], Assert[lambda a: 0 < a < 10_000] ], b: float ): ...","title":"Sequence: chaining Assert and Modify statements"},{"location":"sequence/","text":"Sequence String together Assert and Modify annotations. Basic example The example from typing_exe.annotations import Sequence, Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Sequence[ int, Assert[lambda a: type(a) is int, lambda a: a != 0], Modify[lambda a: abs(a)], Assert[lambda a: a > 5] ] ): ... Explanation When foo gets executed, the following will happen: The first Assert will check a 's type, then check that it is not zero The Modify will then return the absolute value of a The second Assert will check that a is now greater than five The function-body will be executed Description The first entry to the Sequence.__getitem__ -method can either be a typehint or an Assert or Modify . All other entries have to be either an Assert or a Modify . Here are some legal calls to Sequence : from typing_exe.annotations import Sequence, Assert, Modify Sequence[int, Assert[...], Modify[...]] Sequence[Assert[...], Modify[...]] Sequence[Modify[...], Modify[...], Modify[...]] Sequence[str, Modify[...]] Sequence[Assert[...]] # not very useful","title":"Sequence"},{"location":"sequence/#sequence","text":"String together Assert and Modify annotations.","title":"Sequence"},{"location":"sequence/#basic-example","text":"","title":"Basic example"},{"location":"sequence/#the-example","text":"from typing_exe.annotations import Sequence, Assert, Modify from typing_exe.decorators import execute_annotations, cleanup_annotations @cleanup_annotations @execute_annotations def foo( a: Sequence[ int, Assert[lambda a: type(a) is int, lambda a: a != 0], Modify[lambda a: abs(a)], Assert[lambda a: a > 5] ] ): ...","title":"The example"},{"location":"sequence/#explanation","text":"When foo gets executed, the following will happen: The first Assert will check a 's type, then check that it is not zero The Modify will then return the absolute value of a The second Assert will check that a is now greater than five The function-body will be executed","title":"Explanation"},{"location":"sequence/#description","text":"The first entry to the Sequence.__getitem__ -method can either be a typehint or an Assert or Modify . All other entries have to be either an Assert or a Modify . Here are some legal calls to Sequence : from typing_exe.annotations import Sequence, Assert, Modify Sequence[int, Assert[...], Modify[...]] Sequence[Assert[...], Modify[...]] Sequence[Modify[...], Modify[...], Modify[...]] Sequence[str, Modify[...]] Sequence[Assert[...]] # not very useful","title":"Description"}]}